# This script lives in https://devdiv.visualstudio.com/DefaultCollection/Engineering/_git/InitScripts
# Please check into Engineering location first before checkin to Product branches

. "$PSScriptRoot\PackageCache.ps1"
. "$PSScriptRoot\SettingManager.ps1"

$script:AutoGeneratedMessage = "Auto-generated from $PSCommandPath"

filter Skip-Null { $_ | ? { $_ -ne $null } }

function Get-IsAdmin()
{
    $CurrentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $CurrentUserPrincipal = New-Object System.Security.Principal.WindowsPrincipal($CurrentUser)
    return $CurrentUserPrincipal.IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
}

function Create-BatchCmdFiles($properties)
{
    $code = {
        foreach ($kvp in $properties.GetEnumerator())
        {
            $content = @"
:: $AutoGeneratedMessage
@set $($kvp.Name)=$($kvp.Value)
"@
            Set-Content (Get-OutFilePath ("{0}.cmd" -f $kvp.Name)) $content
        }
    }
    Invoke-SynchronizedAccess (Join-Path (Get-OutFilePath) "pkg*.cmd") $code
}

function Create-BuildIncFiles($properties)
{
    $code = {
        foreach ($kvp in $properties.GetEnumerator())
        {
            $content = @"
# $AutoGeneratedMessage
$($kvp.Name)=$($kvp.Value)
"@
            Set-Content (Get-OutFilePath ("{0}.inc" -f $kvp.Name)) $content
        }
    }
    Invoke-SynchronizedAccess (Join-Path (Get-OutFilePath) "pkg*.inc") $code
}

function Invoke-ElevatedCommand([string]$command, [bool]$hidden = $false)
{
    Invoke-CommandWithGlobalGac {
        $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo("cmd")
        $processStartInfo.Arguments = "/c $PSHome\PowerShell.exe $command"
        if($hidden) 
        {
            $processStartInfo.WindowStyle = "Hidden"
        }
        # The runas verb, when applied to an executable will cause it to be 
        # run elevated
        $processStartInfo.Verb = "runas"
        $process = [System.Diagnostics.Process]::Start($processStartInfo)
        $process.WaitForExit()
        if ($process.ExitCode -ne 0)
        {
            if ($process.ExitCode -eq -1073741510)
            {
                Write-Error ("Elevated process was cancelled.")
            }
            else
            {
                Write-Error ("Failed to run as administrator: {0}. Exit code {1:X}." -f $command, $process.ExitCode)
            }
            return $false
        }
        return $true
    }
}

function Create-MsbuildPropsFile($filePath, $properties)
{
    $code = {
        $xml = New-Object System.Xml.XmlTextWriter($filePath, $null)
        $xml.Formatting = 'Indented'
    
        $xml.WriteStartDocument()
        $xml.WriteComment($AutoGeneratedMessage)
        $xml.WriteStartElement("Project")
        $xml.WriteAttributeString("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003")
        $xml.WriteStartElement("PropertyGroup")

        foreach ($kvp in $properties.GetEnumerator())
        {
            $xml.WriteElementString($kvp.Name, $kvp.Value)
        }

        $xml.WriteEndElement()
        $xml.WriteEndElement()
        $xml.WriteEndDocument()
        $xml.Flush()
        $xml.Close()
    }
    Invoke-SynchronizedAccess $filepath $code
}

function Should-UseOfficialBuildProfile()
{
    return ($env:OfficialBuildProfile -eq "true")
}

function Get-CoreXTProfileNames()
{
    if (Should-UseOfficialBuildProfile)
    {
        Save-Profile "CoreXT" "OfficialBuild"
        return "OfficialBuild"
    }
    $coreXtProfileValue = Get-Profile "CoreXT"
    if ($env:CoreXtProfile -and ($env:CoreXtProfile -ne $coreXtProfileValue))
    {
        Write-Warning "Profile overridden by CoreXTProfile profile environment variable, please unset CoreXTProfile and use profile.cmd to set your CoreXT profile."
        Save-Profile "CoreXT" $env:CoreXtProfile
        return $env:CoreXtProfile -split ",\s*"
    }
    return $coreXTProfileValue -split ",\s*"
}

function Invoke-SynchronizedAccess($mutexName, [ScriptBlock]$code)
{
    # Mutex names cannot contain path separator chars
    # See https://msdn.microsoft.com/en-us/library/windows/desktop/ms682411(v=vs.85).aspx
    $mutexName = $mutexName.Replace([IO.Path]::DirectorySeparatorChar, '_')
    $mutex = New-Object System.Threading.Mutex($false, $mutexName)
    try
    {
        if (!$mutex.WaitOne([TimeSpan]::FromSeconds(30)))
        {
            Throw "Cannot synchronize access to mutex '$mutexName'. If another PowerShell process is open that ran init, you may need to close it."
        }
    }
    catch [System.Threading.AbandonedMutexException]
    {
        Write-Warning "Mutex '$mutexName' was abandoned by a different process"
    }

    try
    {
        Invoke-Command $code
    }
    finally
    {
        $mutex.ReleaseMutex()
    }
}

function Invoke-CommandWithGlobalGac([ScriptBlock]$code)
{
    # The existence of COMPlus variables indicate the use of a local GAC
    # By renaming the variables, we can back up the values 
    Get-ChildItem env:COMPlus*  | % { Rename-Item env:$($_.Name) backup.$($_.Name)}
    try
    {
        Invoke-Command $code
    }
    finally
    {
        Get-ChildItem env:backup.COMPlus*  | % { Rename-Item env:$($_.Name) ($_.Name -replace 'backup.')}
    }
}

$retries = 10;
$millisecondsDelay = 5000;

# Refactor this function Execute-Command to 2 functions
# Execute-Command and Execute-CommandCore.
# So that it's easy to mock
function Execute-Command ($command)
{
    $completed = $false;
    $retryCnt = 0;
    while(-not $completed)
    {
        $result = Execute-CommandCore $command
        $retryCnt++
        $output = $result['Output']
        if($result['Success'])
        {
            $completed = $true
        }
        elseif ($retryCnt -ge $retries)
        {
            throw "Failed to run command: $command, error: $output"
        }
        else
        {
            Write-Host "Failed to run command: $command, error: $output. Retrying in $millisecondsDelay ms"
            Start-Sleep -Milliseconds $millisecondsDelay
        }
    }

    return $output
}

function Execute-CommandCore ($command)
{
    try
    {
        # If for some reason there is the git lock file in the repo (from previous operation)
        # then clean it up before running next operation
        $lockFile = [System.IO.Path]::Combine($localPath, ".git", "index.lock")
        If (Test-Path -Path $lockFile)
        {
            try
            {
                Remove-Item $lockFile
            }
            catch
            {
                Write-Host "Failed to delete git lock file at: '$lockFile'. Git command will failed"
            }
        }
        $output = cmd /c $command 2`>`&1
        return @{"Success" = $LASTEXITCODE -eq 0; "Output"=$output}
    }
    catch
    {
        return @{"Success" = $false; "Output"=$_.Exception.Message}
    }
}
